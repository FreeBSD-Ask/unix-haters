# 编程：别动，这一点儿也不疼

![](../.gitbook/assets/chengxuyuan.png)

>“不要干涉 Unix 的事务，因为它微妙且容易迅速发生核心转储。”
>
>——佚名

如果你是通过在 Unix 机器上编写 C 程序学会编程的，那么你可能会觉得本章内容一开始有些令人费解。遗憾的是，Unix 已经如此彻底地占据了全球计算机科学教育体系，以至于如今很少有学生意识到 Unix 的种种失误其实并非真正合理的设计决策。

例如，一位 Unix 爱好者在为 Unix 和 C 辩护时，针对我们提出的存在比 C 更强大语言且这些语言拥有比 Unix 提供的环境更强大高效的编程环境的观点，发表了如下声明：

> 1991 年 11 月 9 日
> 
> 来自：[tmb@ai.mit.edu](mailto:tmb@ai.mit.edu)（Thomas M. Breuel）
> 
> 确实，Scheme、Smalltalk 和 Common Lisp 这样的语言附带了强大的编程环境。然而，Unix 内核、shell 和 C 语言合起来，解决了一些那些语言和环境中未能很好处理（或者根本没有涉及）的宏观问题。
> 
> 这些宏观问题的例子包括内存管理和局部性的某些方面（通过进程创建和退出实现）、持久性（通过将文件作为数据结构实现）、并行性（通过管道、进程和进程间通信实现）、保护和恢复（通过独立地址空间实现），以及可供人类编辑的数据表示形式（文本）。
> 
> 从实际角度来看，这些在 Unix 环境中处理得相当好。

Thomas Breuel 认为 Unix 提供了一种解决计算机科学复杂问题的方法。幸运的是，其他科学领域在解决人类问题时并没有采用这种方法。

> 1991 年 11 月 12 日 星期二 11:36:04 -0500
> 
> 来自：[markf@altdorf.ai.mit.edu](mailto:markf@altdorf.ai.mit.edu)
> 
> 收件人：UNIX-HATERS
> 
> 主题：随机的 Unix 比喻
> 
> 通过进程创建和退出来处理内存管理，就像医学通过生与死来治疗疾病，也就是说，这实际上是在忽视问题。
> 
> 把 Unix 文件（即“字节袋”）作为持久性的唯一接口，就像把你所有东西都扔进衣柜里，然后希望你需要时能找到你想要的东西（不幸的是，我就是这么干的）。
> 
> 通过管道、进程和进程间通信实现并行？Unix 进程开销太大，这并不是一个显著的并行来源。这就像雇主为了解决人员短缺问题，让员工多生孩子一样。
> 
> 是的，Unix 确实擅长处理文本。它也确实擅长处理文本。哦，对了，我提过 Unix 擅长处理文本吗？
> 
> ——Mark

## 奇妙的 Unix 编程环境

Unix 狂热者极力宣扬 Unix 的“编程环境”。他们声称 Unix 拥有丰富的工具集，使编程更加轻松。以下是 Kernighan 和 Mashey 在他们开创性文章《Unix 编程环境》中所说的话：

> Unix 环境中最富有成效的方面之一是它提供了一套丰富的小型、通用的程序——工具——用于帮助日常编程任务。下面展示的程序是其中较为有用的。我们将在本文后续章节用它们来说明其他要点。大多数程序员的工作其实就是运行这些及相关程序。例如，
>
> ```sh
> wc *.c  
> ```
>
> 用于统计一组 C 源文件的行数、单词数和字符数；
>
> ```sh
> grep goto *.c  
> ```
>
> 查找所有的 GOTO。这些居然是“最有用的”之一？！是的。大部分程序员的工作就是这些。事实上，今天我花了大量时间统计我的 C 文件数量，几乎没时间做别的事。我想我还得再去数一次。同一期 IEEE Computer 杂志中另一篇文章是 Warren Teitelman 和 Larry Masinter 撰写的《Interlisp 编程环境》。Interlisp 是一个非常复杂的编程环境。1981 年，Interlisp 拥有的工具是 1994 年的 Unix 程序员只能望洋兴叹的。以下是一些 Unix 常用工具示例：
>
> * wc files：统计文件中的行数、单词数和字符数。
> * pr files：打印文件，带标题和多栏等格式。
> * lpr files：将文件发送到行式打印机。
> * grep pattern files：打印所有包含指定模式的行。
>
> 大多数程序员的工作其实就是运行这些及相关程序。例如，
>
> ```sh
> wc *.c  
> ```
>
> 用于统计一组 C 源文件的行数；
>
> ```sh
> grep goto *.c  
> ```
>
> 查找所有的 GOTO。


这些居然是“最有用的”之一？！


是的。程序员的大部分工作就是如此。事实上，今天我花了这么多时间数我的 C 文件，以至于几乎没时间做别的事情。我想我还得再数一次。

同一期 IEEE Computer 上还有另一篇文章《Interlisp 编程环境》，作者是 Warren Teitelman 和 Larry Masinter。Interlisp 是一个非常复杂的编程环境。早在 1981 年，Interlisp 就拥有一些工具，到了 1994 年，Unix 程序员只能望洋兴叹。Interlisp 环境的设计者采取了完全不同的做法——他们决定开发大型复杂的工具，虽然学习这些工具需要很长时间，但一旦掌握，程序员的生产力将大幅提升。这看起来很合理。

遗憾的是，如今很少有程序员真正体会过如此辉煌的环境。

## 在柏拉图的洞穴中编程

> 我感觉计算机语言设计和工具开发的目标是提升每个人到最高的生产力水平，而不是最低或中等水平。
> 
> ——摘自 comp.lang.c++ 论坛的一则帖子

> 其他行业广泛自动化后，情况并非如此。当人们走进现代自动化的快餐店时，他们期望的是稳定一致，而不是高级美食。大规模提供稳定的平庸，比任何小规模的高效都更有利可图。
> 
> ——一位匿名公司的技术人员对该网络新闻消息的回复[^1]


Unix 不是世界上最好的软件环境——甚至连一个好的环境都算不上。Unix 的编程工具贫乏且难以使用；大多数 PC 调试器都让大部分 Unix 调试器相形见绌；解释器仍然是富人们的玩具；而变更日志和审计记录则取决于被审计者的心情。然而，Unix 却以程序员的梦想环境闻名。也许它让程序员梦想变得高效，而不是真的让他们高效。Unix 程序员就像数学家，这是一种奇特的现象，我们称之为“通过暗示编程”。有一次，我们与一位 Unix 程序员谈论拥有一个可以检查程序、回答诸如“哪些函数调用了函数 foo？”或“哪些函数修改了全局变量 bar？”这样问题的实用工具会有多好，他认同这很有用，但接着说：“你可以写一个这样的程序。”

公平地说，他说“你可以写一个这样的程序”而不是真正去写，是因为 C 语言和 Unix“编程环境”的某些特性相互作用，使得写出这样一个工具极其困难。

你可能觉得我们夸大了，认为这个工具可以通过写几个小工具程序并用管道连接起来轻松实现，但事实并非如此，也做不到。





[^1]: 此人写信告诉我们：“显然，我在 comp.lang.c++ 发布的一条信息被转发到了 UNIX-HATERS 邮件列表。如果我早知道这点，我根本不会发布那条信息。我绝对不希望我的名字或任何我写的内容与‘UNIX-HATERS’这个标题有任何关联。人们误用的风险实在太大了……你们可以使用这段引述，但不能使用我的名字及隶属关系。”





