# csh、管道和 find：强力工具，大力出奇迹

![](../.gitbook/assets/chengxu.png)

---

![](../.gitbook/assets/chengxu2.png)


> 我对所有操作系统都天然的感到反感，尤其是那些缺乏规划，以至于不得不将所有命令命名为消化系统发出的声音（如 awk、grep、fsck、nroff）。
>
>——佚名

Unix 的“动力工具”比喻是个谬论。它不过是一个口号，背后隐藏着 Unix 那些晦涩难懂、拼凑而成的命令和临时工具。真正的动力工具可以在很少额外努力或指导的情况下，放大使用者的力量。任何会用螺丝刀或电钻的人都能使用电动螺丝刀或电钻。使用者不需要理解电力、电机、扭矩、磁力、散热或维护等原理，只需插上电源，戴上护目镜，然后扣动扳机即可。大多数人甚至连护目镜都省了。在五金店，很难找到致命设计缺陷的动力工具：大多数设计糟糕的动力工具要么根本没能上市，要么因诉讼而被迫下架，制造商也受到惩罚。

Unix 的动力工具则不符合这一模式。与其设计者最初期望的简单、单一用途工具不同，如今的 Unix 工具功能过剩、设计过度、过于复杂。例如，ls 这个程序曾经只是列出文件，现在却有超过 18 种不同选项，控制从排序顺序到打印列数等各种功能——这些功能本应由其他工具处理（曾经确实是如此）。find 命令除了找文件，还能输出 cpio 格式的文件，这本来可以通过 Unix 著名的管道连接两个命令轻松完成。现在，Unix 的“动力电钻”可能会有 20 个旋钮和开关，使用非标准插头，需要手动绕线电机线圈，而且还不支持 3/8 寸或 7/8 寸钻头（尽管这会写在说明书的 BUGS 部分）。

与五金店里的工具不同，大多数 Unix 动力工具都有缺陷（有时对文件来说致命）：例如 tar，有其任意的路径名长度限制（100 个字符）；又比如 Unix 调试器，在崩溃时会用自己的“core”文件覆盖掉你的“core”文件。

Unix 的“动力工具”更像是快速且高效切断操作者手指的开关刀。

## shell 游戏

Unix 的发明者有一个伟大的想法：让命令处理器只是另一个用户级程序。如果用户不喜欢默认的命令处理器，他们可以自己编写。更重要的是，shell 可以进化，理应变得更强大、更灵活、更易用。

这是一个很棒的想法，但它却适得其反。功能的缓慢积累导致了混乱。因为这些 shell 不是设计出来的，而是进化而来的，所有编程语言的通病——既有程序基础——对它们冲击更大。一旦一个功能被加入到 shell 中，就会有人写依赖该功能的 shell 脚本，从而保证该功能的延续。糟糕的想法和功能不会消亡。

结果就是今天大量不完整、不兼容的 shell（以下是各 shell 描述，摘自它们各自的 man 页面）：

|   |                  |
| ---- | ------------------------- |
| sh   | 一种命令编程语言，可以执行从终端或文件读取的命令。 |
| jsh  | 与 sh 相同，但启用了类似 csh 的作业控制。 |
| csh  | 具有类似 C 语言语法的 shell。       |
| tcsh | 带有 emacs 风格编辑功能的 csh。     |
| ksh  | KornShell，另一种命令和编程语言。     |
| zsh  | Z Shell。                  |
| bash | GNU 又一款 Bourne SHell。   |


五金店里有三四家公司生产的螺丝刀或锯子，它们的使用方式都差不多。而典型的 Unix /bin 或 /usr/bin 目录里却有上百种不同的程序，由数十个自负的程序员编写，每个程序都有自己独特的语法、操作范式、使用规则（这个是过滤器，这个作用于临时文件等等）、不同的选项指定策略以及一套不同的限制条件。以 grep 程序及其“堂兄”fgrep 和 egrep 为例。哪个最快？[^1]为什么这三个程序的选项不同，并且对“正则表达式”这一短语实现了略有差异的语义？为什么不干脆有一个程序结合这三者的所有功能？到底谁在掌控这一切？

当你掌握了这些不同命令之间的差异，并将这些晦涩内容记忆于心后，你仍然会经常感到震惊和惊讶。

以下几个例子或许能说明问题。

[^1]: 讽刺的是，egrep 甚至可以比 fgrep 快 50%，尽管 fgrep 只使用固定长度字符串，号称搜索“快速且紧凑”。这真是令人费解。

### Shell 崩溃

以下消息发布在哥伦比亚大学一块编译器课程的电子公告板上[^2]。

> 主题：相关的 Unix 漏洞
> 
> 1991 年 10 月 11 日
> 
> W4115x 的同学们——
>
> 既然我们谈到了激活记录、参数传递和调用约定，你们知道在 C shell 中输入：
> 
> ```sh
> !xxx%s%s%s%s%s%s%s%s
> ```
> 
> 会立即导致它崩溃吗？你知道为什么吗？
>
> 思考的问题：
> - 当你输入“!xxx”时，shell 会做什么？
> - 当你输入“!xxx%s%s%s%s%s%s%s%s”时，它对你的输入一定做了什么？
> - 为什么这会导致 shell 崩溃？
> - 你如何（相当容易地）重写 shell 的相关部分，以避免这个问题？
>
> 最重要的是：
> 
> - 你觉得合理吗？你（没错，就是你！）竟然能用 21 个按键让可能成为未来操作系统的 Unix 崩溃？

试试看。按照 Unix 的设计，shell 崩溃会导致你所有的进程被终止，并且你被登出。其他操作系统会捕捉无效的内存引用，然后跳转到调试器里。但 Unix 不会。

或许这就是为什么 Unix shell 不允许你通过加载新的目标代码到它们的内存映像中，或者调用其他程序中的目标代码来扩展它们。那样做太危险了。一不小心——砰——你就被登出了。对程序员错误零容忍。


[^2]: 由 John Hinsdale 转发给 Gumby，Gumby 又将其转发给 Unix 痛恨者。


### 元语法动物园

C Shell 的元语法操作符动物园导致了许多引用问题和普遍的混乱。元语法操作符会在命令执行之前对命令进行转换。我们称这些操作符为元语法操作符，是因为它们不是命令语法的一部分，而是作用于命令本身的操作符。元语法操作符（有时也称为转义操作符）对大多数程序员来说都很熟悉。例如，C 语言字符串中的反斜杠字符（`\`）就是一种元语法操作符；它不表示自身，而是对后续字符进行某种操作。当你想让元语法操作符表示它自己时，必须使用一种引用机制，告诉系统将该操作符解释为普通文本。比如，回到 C 语言字符串的例子，要表示字符串中的反斜杠字符，就必须写成 `\`。


在 C Shell 中，简单的引用机制几乎不起作用，因为 shell 与它代表用户调用的程序之间没有任何约定。例如，想想下面这个简单命令：

```sh
grep 字符串 文件名:
```

字符串参数包含由 grep 定义的字符，比如 `?`、`[` 和 `]`，这些字符对 shell 来说是元语法的。这意味着你可能需要对它们进行引用，但这也取决于你使用的 shell 以及环境变量的设置。

搜索包含句点或以连字符开头的模式会使问题更加复杂。务必正确引用你的元字符。遗憾的是，就像模式匹配一样，操作系统中存在多种不兼容的引用规范。

C Shell 的元语法动物园里有七个不同家族的元语法操作符。因为这个“动物园”是在一段时间内逐渐“填充”起来的，而且“笼子”是锡制而不是钢制的，这些“居民”往往会互相冲突。对 shell 命令行的七种不同转换是：


|         |               |
| --------- | --------------- |
| 别名定义与取消别名 | `alias` 和 `unalias` |
| 命令输出替换    | \`              |
| 文件名替换     | `*`、`?`、`[]`      |
| 历史命令替换    | `!`、`^`            |
| 变量替换      | `$`、`set`、`unset`  |
| 进程替换      | `%`               |
| 引号        | `'`、`"`            |

由于这种“设计”，问号字符注定只能用于单字符匹配：它永远不能在命令行上用作帮助符号，因为它从不传递给用户的程序，因为 Unix 要求这个元语法操作符必须由 shell 解释。

如果这七类不同的元语法字符遵循一个逻辑的操作顺序，并且它们的替换规则被统一应用，那也不算太糟糕。但事实并非如此，它们既没有统一的顺序，也没有统一的规则。


> 日期：1990 年 5 月 7 日 星期一 18:00:27 -0700
> 发件人：Andy Beals [bandy@lll-crg.llnl.gov](mailto:bandy@lll-crg.llnl.gov)
> 主题：回复：今天的抱怨：fg %3
> 收件人：UNIX-HATERS
>
> 不仅可以说 %emacs，甚至 %e 来重启一个作业（如果它是唯一匹配的），你也可以用 %?foo 来匹配命令行中包含子串“foo”的作业。
> 当然，!ema 和 !?foo 也可以用于历史替换。
> 但是，UCB 的笨蛋们没有让 !?foo 识别后续的编辑命令，所以那个脑残的 c-shell 无法识别像
>
> ```sh
> !?foo:s/foo/bar&/:p
> ```
>
> 这样的命令，这让输入变得痛苦。
>
> 真有那么难往前扫描找那个编辑字符吗？

这些内容即使对 Unix“专家”来说也有些令人困惑。以 Milt Epstein 为例，他想写一个 shell 脚本，能够准确获取正在输入的命令行内容，而不经过 shell 的任何预处理。他发现这并不容易，因为 shell 为程序“代劳”了太多工作。要避免 shell 的处理，需要使用一种极为复杂晦涩的魔法般语法，连大多数专家也难以理解。这就是 Unix 的典型特征——使看似简单的事情变得异常困难，仅仅因为当初设计 Unix 时并未考虑到这些需求。

> 日期：1991 年 8 月 19 日 15:26:00 GMT
> 
> 发件人：[Dan\_Jacobson@att.com](mailto:Dan_Jacobson@att.com)
> 
> 主题：/bin/sh 系列 shell 脚本中的 `${1+“$@”}`
> 
> 新 sgroups：comp.emacs, gnu.emacs.help, comp.unix.shell
>
> >  1991 年 8 月 18 日 星期日 18:21:58 -0500，
> >  Milt Epstein [epstein@suna0.cs.uiuc.edu](mailto:epstein@suna0.cs.uiuc.edu) 说：
> 
>  Milt> `${1+“$@”}` 是什么意思？我确定它是
> 
>  Milt> 用来读取剩下的命令行参数的，但
> 
>Milt> 我不太确定具体含义。
>
> 这是在 `/bin/sh` 系列 shell 脚本中精确复现命令行参数的方法。
> 
> 它说：“如果至少有一个参数（`${1+}`），那么就替换所有参数（`"$@"`），保持每个参数内的所有空格等。
> 
> 如果我们只用 `"$@"`，当没有调用参数时，它会被替换成 `""`（一个空参数），但我们想要的是在这种情况下不产生任何参数，而不是一个空字符串。
> 
> 为什么不用 `"$*"` 等呢？摘自 sh(1) 手册页：”
> 
> > 在一对双引号（“”）内，会发生参数和命令替换，shell 会对结果加引号以避免空白被解释和文件名生成。如果 $\* 在双引号内，位置参数会被替换并加引号，用加引号的空格分隔（“\$1 \$2 …”）；但是，如果 \$@ 在双引号内，位置参数会被替换并加引号，用不加引号的空格分隔（“\$1” “\$2” …）。
> 我认为 `${1+“$@”}` 的可移植性可以一直追溯到“第七版 Unix”。

哇！竟然可以追溯到第 7 版。


### Shell 命令“chdir”不能用

Bug 和明显的古怪行为，是 Unix 由众多作者长期演进的结果，这些作者各自尝试将操作系统引向不同的方向，却无人停下来考虑彼此之间的影响。


> 日期：1990 年 5 月 7 日 星期一 22:58:58 EDT
> 
> 发件人：Alan Bawden <alan@ai.mit.edu>
> 
> 主题：cd . . ：我没有编造这个
> 
> 收件人：UNIX-HATERS  
>  
> 有什么命令比“cd”更直接明了的吗？我们来看一个简单的例子：“cd ftp。”  
> 如果我当前目录是 `/home/ar/alan`，并且它有一个名为“ftp”的子目录，那么这个子目录就成为了我的新当前目录。  
> 所以现在我就在 `/home/ar/alan/ftp`。很简单。  
>  
> 你们都知道“.”和“..”吧？每个目录总有两个条目：一个叫“.”，指向目录本身；一个叫“..”，指向该目录的父目录。所以在我们的例子里，我可以通过输入“cd ..”回到 `/home/ar/alan`。  
>  
> 现在假设“ftp”是一个符号链接（请耐心听我说完）。假设它指向目录 `/com/ftp/pub/alan`。那么执行“cd ftp”后，我就进入了 `/com/ftp/pub/alan`。  
>  
> 像所有目录一样，/com/ftp/pub/alan 也有一个条目叫“..”，它指向它的上级目录：`/com/ftp/pub`。假设我想接下来去那里，我输入：  
>  
> ```sh
> % cd ..
> ```  
>  
> 猜猜看？我回到了 /home/ar/alan！shell 中的某个地方（显然我们 AI 实验室用的是叫“tcsh”的 shell）记住了为了进入 `/com/ftp/pub/alan` 而追踪了符号链接，cd 命令猜测我宁愿回到包含该链接的目录。如果我真的想访问 `/com/ftp/pub`，我应该输入“cd ./..”。



## Shell 编程

Shell 程序员和《侏罗纪公园》里的恐龙克隆者有许多相似之处。他们没有所有需要的“基因片段”，于是用随机的基因材料来填补缺失的部分。尽管他们充满自信且能力出众，但并不总能完全控制自己的“创造物”。

理论上，shell 程序相比用 C 语言写的程序有一个巨大优势：shell 程序具有可移植性。也就是说，用 shell“编程语言”写的程序可以运行在许多不同版本的 Unix 系统上，运行于各种不同的计算机架构，因为 shell 是解释执行程序，而不是将其编译成机器码。而且，sh，作为标准的 Unix shell，自 1977 年起就成为 Unix 的核心组成部分，因此几乎可以在任何机器上找到它。

现在，我们用一个示例来检验这一理论：写一个 shell 脚本，使用 file 命令打印当前目录中每个文件的名称和类型。


> 日期：1992 年 4 月 24 日 星期五 14:45:48 EDT
> 
> 发件人：Stephen Gildea <gildea@expo.lcs.mit.edu>
> 
> 主题：简单的 Shell 编程
> 
> 收件人：UNIX-HATERS  
>  
> 大家好，今天我们将学习用“sh”编程。  
> “sh”shell 是一个简单且多功能的程序，但我们先从一个基本例子开始：  
> 打印目录中所有文件的类型。  
> （后面有人发出了声音！那些对 shell 有点了解并觉得无聊的，可以写“在远程机器上启动一个 X11 客户端”来加分。暂时先别吭声！）  
>  
> 在学习 sh 的同时，我们也希望写出的程序健壮、可移植且优雅。  
> 我假设大家都看过相关的手册页，所以下面的内容应该很明显：  
>  
> ```sh
> file *
> ```  
>  
> 很好，不是吗？简单问题的简单解决方案；星号匹配目录中所有文件。  
> 不过，也不完全是这样。以点开头的文件被认为是不重要的，而 * 不会匹配它们。  
> 可能没有这样的文件，但为了健壮，我们用“ls”并加一个特殊选项：  
>  
> ```sh
> for file in `ls -A`
> do
> file $file
> done
> ```  
>  
> 这样：优雅且健壮……哎呀，有些系统的“ls”不支持“-A”选项。没关系，我们用 -a 代替，然后过滤掉 . 和 .. 文件：  
>  
> ```sh
> for file in `ls -a`
> do
> if [ $file != . -a $file != .. ]
> then
> file $file
> fi
> done
> ```  
>  
> 没那么优雅，但至少健壮且可移植。什么？“ls -a”也不是处处可用？没问题，我们用“ls -f”替代，速度也快。  
> 我希望这些都能从手册页里看出来。  
>  
> 嗯，似乎也不算太健壮。Unix 文件名可以包含任何字符（除了斜杠），文件名中有空格会打破这个脚本，因为 shell 会把它当成两个文件名解析。  
> 这不难解决。我们只需改变 IFS，不包含空格（或者同时去掉制表符），并且小心地给变量加引号（不过也不能多或少），比如这样：  
>  
> ```sh
> IFS='
> '
> for file in `ls -f`
> do
> if [ "$file" != . -a "$file" != .. ]
> then
> file "$file"
> fi
> done
> ```  
>  
> 你们中有些机灵的人可能已经注意到，问题虽变小了，但没消除，因为换行符也是文件名中合法字符，它仍然在 IFS 里。  
> 脚本失去了一些简洁性，是时候重新评估我们的做法了。  
> 如果去掉“ls”，就不用担心解析它的输出了。那下面这样如何？  
>  
> ```sh
> for file in .* *
> do
> if [ "$file" != . -a "$file" != .. ]
> then
> file "$file"
> fi
> done
> ```  
>  
> 看起来不错。处理了点文件和带有不可打印字符的文件。  
> 我们不断往测试目录里添加各种奇怪命名的文件，这个脚本依旧有效。  
> 但有人在空目录试用时，* 模式会产生“No such file”的错误。我们可以加个检测……  
>  
> ……到这里，我的邮件可能对你们中一些用 uucp 邮件系统的人来说太长了，所以我得先写到这里，剩下的 Bug 修正留给读者作为练习。  
>  
> Stephen  

还有一个重大问题，从一开始我们一直在回避不提。那就是 Unix 的 file 程序根本就不靠谱。


> 日期：1992 年 4 月 25 日 星期六 17:33:12 EDT
> 
> 发件人：Alan Bawden <Alan@lcs.mit.edu>
>   
> 主题：简单 Shell 编程
> 
> 收件人：UNIX-HATERS  
>  
> 哇！等等，回头。你真的打算用 `file` 程序？想找乐子的人应该立刻停下来，找一台 Unix 机器，在一个杂七杂八的目录里试试输入“file *”。  
>  
> 例如，我刚刚对一个充满 C 源代码的目录运行了 `file` —— 以下是部分结果：
> ```sh
> arith.c: c program text  
> binshow.c: c program text  
> bintxt.c: c program text
> ```
> 目前还不错。但然后：
> ```sh
> crc.c: ascii text
> ```
> 你看，`file` 并没有看文件名里的 `.c`，而是根据文件内容用一些启发式方法来判断。显然 `crc.c` 看起来不像 C 代码——尽管对我来说它肯定是。
> ```sh
> gencrc.c.~4~: ascii text  
> gencrc.c: c program text
> ```
> 我猜我在版本 4 之后改了什么，让 `gencrc.c` 看起来更像 C 代码了……
> ```sh
> tcfs.h.~1~: c program text  
> tcfs.h: ascii text
> ```
> 而 `tcfs.h` 在版本 1 之后看起来就不像 C 代码了。
> ```sh  
> time.h: English text
> ```
> 没错，time.h 看起来像英文，而不仅仅是 ascii。我想知道 `file` 是否有识别西班牙语或法语的规则？（顺便说一句，你典型的 TeX 源文件会被分类为“ascii text”而非“English text”，不过我扯远了……）
> ```sh
> words.h.~1~: ascii text  
> words.h: English text
> ```
> 也许我在版本 1 之后给 words.h 加了一些注释？  
>  
> 但我留的最好的是：
> ```sh
> arc.h: shell commands  
> Makefile: [nt]roff, tbl, or eqn input text
> ```
> 都完全错了。我真想知道如果我试图按 `file` 程序给出的类型去使用它们，会发生什么？  
>  
> ——Alan


### Shell 变量不起作用

Alan 的情况还能更糟，比如他可能正在尝试使用 shell 变量。

正如我们之前提到的，sh 和 csh 对 shell 变量的实现略有不同。这本来不算太糟糕，但 shell 变量的语义——何时定义、变更操作的原子性以及其他行为——在很大程度上都是未文档化且定义模糊的。shell 变量经常表现出奇怪且违反直觉的行为，只有经过大量实验才能理解。


> 日期：1991 年 11 月 14 日 星期四 11:46:21 PST
> 
> 发件人：Stanley’s Tool Works <lanning@parc.xerox.com>
> 
> 主题：你每天都会学到新东西
> 
> 收件人：UNIX-HATERS  
>  
> 运行这个脚本：  
>  
> ```sh
> #!/bin/csh
> unset foo
> if ( ! $?foo ) then
> echo foo was unset
> else if ( "$foo" = "You lose" ) then
> echo $foo
> endif
> ```  
>  
> 会产生这个错误：  
> foo: Undefined variable.  
>  
> 要让脚本“做正确的事情”，你必须写成这样：  
>  
> ```sh
> #!/bin/csh
> unset foo
> if ( ! $?foo ) then
> echo foo was unset
> set foo
> else if ( "$foo" = "You lose" ) then
> echo $foo
> endif
> ```  
>  
> [注意在发现变量未设置后需要执行 `set foo`。]  
>  
> 清楚了吗？


### 错误代码与错误检查


我们的编程示例忽略了 file 命令如何向 shell 脚本报告错误。其实，它根本不报告错误。错误被忽略了。这种行为不是疏忽：大多数 Unix shell 脚本（以及其他程序）都会忽略它们调用的程序可能产生的错误代码。这种行为可以理解，因为没有统一的标准规范来指定程序应该返回哪些代码来表示错误。

或许错误代码被普遍忽略的原因，是因为在用户在 shell 提示符下输入命令时，错误代码不会被显示。错误代码和错误检查在 Unix 规范中几乎不存在，导致许多程序甚至根本不报告错误。


> 日期：1992 年 10 月 6 日 星期二 08:44:17 PDT
>  
> 发件人：Bjorn Freeman-Benson <bnfb@ursamajor.uvic.ca>
> 
> 主题：在 Unix 世界里总是好消息
> 
> 收件人：UNIX-HATERS  
>  
> 试想这个 tar 程序。像所有 Unix“工具”（我用这个词很宽泛）一样，它以奇怪且独特的方式工作。比如，tar 是一个充满正能量的程序，因此它坚信不会发生任何坏事，所以它从不返回错误状态。实际上，即使它向屏幕打印错误信息，它仍然报告“好消息”，即状态码为 0。  
>  
> 在 shell 脚本中试试这个：  
>  
> ```sh
> tar cf temp.tar no.such.file
> if( $status == 0 ) echo "Good news! No error."
> ```  
>  
> 你会得到：
> ```sh 
> tar: no.such.file: No such file or directory  
> Good news! No error.  
> ```
> 我知道——我本不该期待任何一致、有用、文档完善、快速，甚至能用的东西……

> Bjorn



## 管道


> 我的 Unix 判断是我自己的。大约六年前（当我第一次拿到工作站时），我花了大量时间学习 Unix，学得相当不错。幸运的是，那些垃圾大部分现在已经从记忆中消失了。然而，自从加入这个讨论后，许多 Unix 支持者给我发来了各种示例，想“证明”Unix 的强大。这些例子确实足以让我回想起来：它们都做了一些琐碎或无用的事情，而且都是以非常晦涩难懂的方式完成的。
> 
> 有人在网上发帖说他从一个 shell 脚本中“顿悟”了（该脚本用了四个命令，整个脚本看起来像是乱码），它把所有 '.pas' 文件的后缀改成了“.p”。我把我的宗教狂喜留给比重命名文件更重要的事情。事实上，这就是我对 Unix 工具的记忆——你花了所有时间学着做复杂且奇怪的事，但最终并没有多么令人印象深刻。我决定还是学点真正能干活的东西。  
>  
> ——Jim Giles
> 
> 洛斯阿拉莫斯国家实验室






