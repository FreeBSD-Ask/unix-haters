# 欢迎，新用户！ 就像装满六发子弹的俄罗斯轮盘赌

![](../.gitbook/assets/newuser.png)

>有一辆 Ken Thompson 参与设计的汽车。与大多数汽车不同，这辆车没有速度表、油量表，也没有那些困扰现代司机的各种愚蠢警示灯。相反，如果司机犯错，仪表盘中央会亮起一个巨大的“？”符号。Thompson 说：“有经验的司机通常会知道出了什么问题。”
>
>——佚名

计算机系统的新用户（甚至是经验丰富的用户）都需要系统给予一定程度的友好支持。至少，一个友好的计算机系统应为其用户提供以下便利：

* 符合功能逻辑的命令名称
* 对危险命令的谨慎处理
* 命令行为及其选项和参数解释上的一致性和可预测性
* 容易查找且易读的在线文档
* 命令失败时提供可理解且有用的反馈

Unix 在开发期间，并没有接待任何访客。每一位来访者都是戴着安全帽的承包商，被指派去完成营房中尚未完成的部分。不幸的是，不仅从未邀请过人因工程师参与设计，甚至从未预见或规划过他们的需求。因此，许多标准设施，比如抽水马桶、中央供暖和可开启的窗户，现在都极其难以且昂贵地进行改装。尽管如此，建造者们仍对它的设计赞叹不已，以至于他们甘愿在没有烟雾探测器的房间地板上睡觉。

在大部分历史中，Unix 是大学和工业研究人员的研究平台。随着廉价工作站的爆炸性增长，Unix 进入了一个新的时代——交付平台时代。这个变化很容易确定时间点：当工作站厂商为了降低非开发者的价格，将 C 编译器从标准软件套件中拆分出来时。这一变化的界限在化石记录中略显模糊，但大多发生在 1990 年左右。因此，只有在过去几年中，厂商才真正开始关心终端用户的需求和期望，而非程序员。这也解释了为什么如今公司们试图编写图形用户界面来“替代” shell 的需求。我们并不羡慕这些公司的任务。

## 神秘难懂的命令名称

新手 Unix 用户总是对 Unix 所选择的命令名称感到惊讶。无论在 DOS 还是 Mac 上接受多少培训，都无法为你准备好去欣赏那些神秘而简短的两个字母命令，比如 cp、rm 和 ls 的“壮丽之美”。

我们这些使用过七十年代初期输入/输出设备的人怀疑，这种简短命令的退化，源于当时常用的 ASR-33 电传打字机的速度、可靠性，尤其是键盘的限制。与现代键盘不同，现代键盘按键行程的设计基于反馈原理，所需力量仅是关闭微动开关的力，而当时电传打字机的按键（据记忆）需要行程超过半英寸，而且需要施加类似骑自行车发电机的力量。用这些“怪兽”触摸打字，甚至可能撞破你的指关节。

如果 Dennis 和 Ken 用的是 Selectric 打字机而不是电传打字机，我们现在可能会打“copy”和“remove”而不是“cp”和“rm” [^1]。这再次证明，技术既限制了我们的选择，也扩展了我们的可能。

经历了二十多年，继续沿用这种传统的理由是什么？历史的不可抗拒力量，也就是现有的代码和书籍。如果某个厂商把 rm 替换成“remove”，那么所有描述 Unix 的书籍将不再适用，该厂商系统上的所有调用 rm 的 shell 脚本也将失效。这样的厂商还不如干脆停止执行 POSIX 标准。

一个世纪以前，快速的打字员让键盘卡住，于是工程师设计了 QWERTY 键盘来减慢他们的速度。计算机键盘不会卡键，但我们至今仍在使用 QWERTY 键盘。再过一百年，世界仍然会继续使用 rm 命令。

[^1]: 有一次，有记者问 Ken Thompson 如果让他重新设计 Unix，他会改什么。他的回答是：“我会把 creat 拼成 create。”

## 意外总会发生

用户非常关心他们的文件和数据。他们使用计算机来生成、分析和存储重要信息，信任计算机能够保护这些宝贵的资料。没有这种信任，用户与系统的关系就会变得紧张。Unix 滥用我们的信任，固执地拒绝保护用户免受危险命令的伤害。特别是 rm 这个最危险的命令，其存在的唯一理由就是删除文件。

所有 Unix 新手都曾“意外”且不可恢复地删除过重要文件。即使是专家和系统管理员也会“意外”删除文件。因丢失时间、努力和文件恢复而产生的费用可能每年达数百万美元。这本应是一个值得解决的问题；我们不明白为什么 Unix 用户对此视而不见。难道痛苦真的这么喜欢有伴吗？

文件在 Unix 下比在其他任何操作系统中更频繁地“死亡”并需要“重生”，原因如下：

1. Unix 文件系统没有版本号。自动文件版本控制，会给文件的新版本赋予新名字或编号后缀，从而保留文件的旧版本，避免新版本覆盖旧版本。而覆盖在 Unix 中经常发生。

2. Unix 程序员对错误报告和检查的态度极其宽松。许多程序根本不检查输出文件的所有字节是否能成功写入磁盘，有些甚至不确认输出文件是否创建成功。然而，这些程序在完成后肯定会删除输入文件。

3. 是 Unix shell（命令行解释器），而不是客户端程序，来扩展通配符“*”。shell 扩展“*”导致客户端程序（如 rm）无法进行合理检查以防止灾难。即使是 DOS 也会验证像“del *.*”这样危险的命令，但在 Unix 中，删除文件的程序无法区分用户是输入了：

```sh
% rm *
```
   还是

```sh
% rm 文件1 文件2 文件3 ...
```

如果能保存并传递原始命令行给被调用的客户端命令，这种情况会有所改善。也许可以利用环境变量来实现。

4. 文件删除是永久性的。Unix 没有“undelete”（撤销删除）命令。其他更安全的操作系统中，删除文件会将文件所占用的磁盘块标记为“可用”，并将目录项移动到一个专门的“已删除文件”目录里。只有当磁盘空间不足时，这些已删除文件占用的空间才会被回收。

大多数操作系统采用这种“删除-清空”的两步机制来将文件占用的磁盘块归还给系统。这并不是高深的技术，甚至早在 1984 年，Macintosh 就将“扔进垃圾桶”和“清空垃圾桶”区分开了。Tenex 在 1974 年就已经实现了这一点。

DOS 和 Windows 给你的东西更像是带有存水弯的污水管道，而不是垃圾桶。它们只是简单地删除文件，但如果你想“伸手”把文件找回来，至少还有一些可以购买的工具来完成这项工作。这些工具确实有效——不过只是有时有效。

这四个问题相互作用，导致了无谓但可预见且每天都会发生的文件删除。比 Unix 出现之前，人们已经理解并广泛使用了更好的技术。而如今，随着 Unix 被接受为世界上的“标准”操作系统，这些技术正逐渐被遗忘。
欢迎来到未来。

## “rm” 是永远的灾难

上述原则结合起来，形成了现实生活中的恐怖故事。Usenet 新闻组 alt.folklore.computers 上的一系列交流说明了我们的观点：

>日期：1990 年 1 月 10 日 星期三
>
>发件人：[djones@megatest.uucp](mailto:djones@megatest.uucp)（Dave Jones）
>
>主题：rm \*
>
>新闻组：alt.folklore.computers2 [^2]
>
>有没有人曾打算输入：
>
>```sh
>% rm *.o
>```
>
>却不小心输入成了：
>
>```sh
>% rm *>o
>```
>
>现在你得到一个新的空文件叫做“o”，但它占用了大量空间！

实际上，你甚至可能不会得到名为“o”的文件，因为 shell 文档并没有明确说明输出文件“o”是在通配符展开之前还是之后创建的。shell 虽然是编程语言，但它不是很精确。

[^2]: 由 Chris Garrigues 转发至 UNIX-HATERS。

>日期：1990 年 1 月 10 日 星期三 15:51 CST
>
>发件人：[ram@attcan.uucp](mailto:ram@attcan.uucp)
>
>主题：回复：rm \*
>
>新闻组：alt.folklore.computers
>
>我也经历过类似的 rm 灾难。有一次，我要从磁盘上删除一个文件系统，类似于 `/usr/foo/bin`。我当时在 `/usr/foo` 目录下，已经通过以下命令删除了系统的几个部分：
>
>```sh
>% rm -r ./etc
>% rm -r ./adm
>```
>……诸如此类。但当轮到删除 `./bin` 时，我漏打了那个点。系统对此反应很糟糕。

Unix 并没有设计成能在失去其 /bin 目录这种致命打击后继续存活的智能操作系统。一个智能的操作系统本该给用户一个恢复的机会（或者至少确认用户是否真的想让操作系统变得无法使用）。
Unix 爱好者把偶尔的文件删除当作正常现象。例如，看看 comp.unix.questions FAQ [^3] 中的以下摘录：

>6）如何“恢复删除”的文件？
>
>总有一天，你会不小心输入类似这样的命令：
>
>```
>% rm * .foo
>```
>
>结果你实际上删除了“`*`”而不是“`*.foo`”。把这看作是一个成长的仪式。
>
>当然，任何体面的系统管理员都应该定期做备份。联系你的系统管理员，看看是否有最近的备份文件可用。

“成长的仪式”？在其他任何行业，制造商都不可能对有缺陷的产品持如此轻率的态度。“但法官大人，爆炸的油箱不过是成长的仪式。”“各位陪审团成员，我们将证明因安全装置失效导致的损害……”

“电锯对它的用户来说也只是一条成长的必经之路。”“法庭阁下，我们将证明，被基廷先生骗走毕生积蓄的退休人员，也只是经历了一个成长的必经之路。”没错。

[^3]: comp.unix.questions 是个国际性的公告板，新的 Unix Gulag 用户会在这里向那些待得太久、已经不知道其他世界的人提问。FAQ 是一份常见问题列表，汇集了众多用户“自伤”的报告。

## 无法通过改变 rm 的行为来解决问题

被 rm 咬了几次之后，人们往往会冲动地给 rm 命令设置别名，使其变成 “rm -i”，或者更好的是，用一个程序替换 rm 命令，将要删除的文件移动到一个特殊的隐藏目录，比如 \~/.deleted。这些做法会让无辜的用户产生一种虚假的安全感。


>日期：1990 年 4 月 16 日星期一 18:46:33
>
>发件人：Phil Agre <agre@gargoyle.uchicago.edu>
>
>收件人：UNIX-HATERS
>
>主题：删除
>
>在我们的系统上，“rm” 并不删除文件，而是以某种晦涩的方式重命名文件，以便所谓的“undelete”（不是“unrm”）可以恢复它。
>
>这让我在删除文件时有些不小心，因为我总以为自己可以随时恢复它们。其实不然。Emacs 中的删除文件命令并不是这样工作的，Dired 中的 D 命令也不是如此。原因当然是因为撤销删除的协议并不是操作系统文件模型的一部分，而只是某个叫做“rm”的 shell 命令中被人为拼凑进去的一部分。
>
>因此，我必须在脑海中保持两个不同的概念——“删除”文件和“用 rm 删除”文件，并时刻提醒自己，当我的大脑对我的手说“删除它”时，我实际上是在执行哪一个操作。

一些 Unix 专家顺着 Phil 的论点推向逻辑上的荒谬，坚持认为最好不要让像 rm 这样的命令变得哪怕稍微友好一点。他们的论点虽然不是用我们所用的表达方式，但认为试图让 Unix 更加友好，赋予它基本的便利设施，实际上会让它变得更糟。不幸的是，他们是对的。

> 日期：Thu, 11 Jan 90 17:17 CST
>
> 来自：[merlyn@iwarp.intel.com](mailto:merlyn@iwarp.intel.com)（Randal L. Schwartz）
>
> 主题：不要重载命令！（原主题：Re: rm \*）
> 
> 新闻组：alt.folklore.computers
>
> 我们打断本新闻组的正常内容，带来以下信息……
> 
>```c
>#ifdef SOAPBOX_MODE
>```
> 请，拜托，请不要鼓励大家用“安全”命令去重载标准命令。
>
> （1）人们通常把它放在 .cshrc 文件错误的位置，导致那些想用“rm”命令删除文件的脚本莫名其妙地要确认，
> 或者误以为文件已被删除，结果把磁盘填满了。
>
> （2）没有办法保护所有可能意外删除文件的情况，如果你保护了一个常用的，用户就会认为“任何操作都可以撤销”（绝对不是真的！）。
>
> （3）如果用户请系统管理员（我现在正戴着这个帽子）在终端帮忙，命令不按正常方式运行，当你有用户要帮忙，还有四个“紧急：现在需要处理”的任务排队时，这真的令人抓狂。
>
> 如果你想要一个“rm”命令会要求确认，请用：
> 
>```sh
>% alias del rm -i
>```
> 并且不要用 rm！哎，人们，这有多难？！？
>
> ```sh
> #endif
> ```
> 现在恢复你们原定的“我敲代码敲得那么久，机器只有零，没有零和一”的讨论……
>
> 只是另一个系统黑客

最近，有人在 comp.unix.questions 发布请求，征集系统管理员们最喜欢的管理员恐怖故事。在 72 小时内，收到了 300 条留言。其中大多数都涉及本章所述的方法导致文件丢失。有趣的是，这些都是经验丰富的 Unix 用户，本应更为谨慎。更奇怪的是，尽管这些消息中报告了数百万美元的损失，但当 Unix 被批评“不够用户友好”时，绝大多数系统管理员却站出来为 Unix 辩护。

不用户友好？Unix 甚至都不是“系统管理员友好”！例如：

> 日期：1988 年 9 月 14 日 星期三 01:39 EDT
> 
> 发件人：Matthew P Wiener [weemba@garnet.berkeley.edu](mailto:weemba@garnet.berkeley.edu)
> 
> 收件人：RISKS-LIST\@kl.sri.com4
> 
> 主题：回复：“单击键”
>
> 在 Unix 上，即使是有经验的用户也可能因为 “rm” 做出很大破坏。我从未费心写过安全的 rm 脚本，因为我不会误删文件。然后有一天，我倒霉地敲了 “`!r`” 来重复历史命令列表中的某条命令，惊恐地看到屏幕回显 “`rm -r *`”——那是我之前在另一个目录下执行过的命令，那个目录我花时间清理过。
>
> 也许 C shell 可以增加一个 nohistclobber 选项？这仍然是我唯一一次误删或覆盖文件，而且这完全是个最低级别的意外陷阱！
>
> 巧合的是，就在前几天，我听到一个天真的用户对运行 “rm *” 删除了他刚刚从邮件中错误创建的文件 “*” 的恐惧。幸运的是，按字母顺序排得靠前的文件没有写权限，所以删除操作很快就停止了。


这条信息的作者建议通过给 shell 添加一个“nohistclobber 选项”（禁止历史命令覆盖）来进一步修改，以弥补操作系统对星号名称展开机制的根本缺陷。不幸的是，这种“修补”就像用一层新油漆来修复受水损坏的墙壁，效果差强人意。

